{
    "contents" : "---\ntitle: \"Exploration for Data Filtering Speed\"\nauthor: \"Anna Steel\"\ndate: \"August 12, 2016\"\noutput: html_document\n---\n\n```{r, include=FALSE} \n# required packages\nlibrary(dplyr)\nlibrary(sp)\nlibrary(rgdal)\nlibrary(rgeos)\nlibrary(ggplot2)\nlibrary(grid) \nlibrary(cowplot)\nlibrary(viridis)\nlibrary(adehabitatLT)\n```\n\n### Load and prepare dataset \n- add UTM coordinates\n```{r}\nload(\"Maestros/AllFishHPEfilt.RData\")\n\n# Critical to order this properly for the ordered step analysis below (TypeI)\nreddf = reddf[order(reddf$Id, reddf$Time),]  \n  reddf$IDcol = 1:nrow(reddf)\n\n# # convert the Lat Long into UTMs using 'sp'\nreddf.sp <- SpatialPointsDataFrame(coords = reddf[,c(\"Longitude\",\"Latitude\")], \n              data = reddf, proj4string=CRS(\"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\"))\n        # confirmed string with VEMCO; the XY coords in azimuthal equal area\nreddf.utm <- spTransform(reddf.sp, CRS(\"+proj=utm +zone=10 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0\"))\n reddf.utm@data[,c(\"east\",\"north\")] <- reddf.utm@coords\n \n reddf2 = reddf.utm@data    \n```\n\n### Use adehabitatLT to calculate descriptive metrics for each unprocessed track\n- irregular typeII track (time is recorded, not just order, and points are not evenly distributed)\n- calculates distance between points, time lapsed between points, turning angles, and direct distance from start point\n-- Use UTM  so distances calculated in meters not degrees\n-- Note: the distance & time calculates is the distance traveled in the SUBSEQUENT step (i to i+1)\n- I add speed between each step, mean speed over ground for each animal, and mean speed for all fish\n```{r}\n   red.ltraj = as.ltraj(xy=reddf2[,c(\"east\",\"north\")], date=reddf2$Time, \n                        id=reddf2$Id, infolocs = reddf2[,c(\"Id\",\"Hpes\")])\n \n   red2 = ld(red.ltraj)\n   red2$spd_mps = red2$dist / red2$dt\n   \n   meanspds = data.frame(summarize(group_by(red2, Id), mean_mps=mean(spd_mps, na.rm=T), sd_mps=sd(spd_mps, na.rm=T)))\n   \n   print(paste0(\"mean speed over ground (mean of fish means) = \", round(mean(meanspds$mean_mps, na.rm=T),2), \"(SD=\", round(sd(meanspds$sd_mps, na.rm=T),2), \") meters per second\"))\n    \n```\n\n### Identify questionable detections based on speeds to and from point\nThe concept here is that some points with low HPEs values are still erronious positions.\nIf the speed over ground is excessive in both the prior (i-1) and subsequent (i) steps, it is likely that the position (i) has extordinarily high error and should be removed. \nWe will begin by considering any points greater than 10.6 (99.5% quantile) as erronious, then reassess the tracks to see if we need to set a lower cutoff\n```{r}\nhist(red2$spd_mps, xlim=c(0,50), breaks=200, ylim=c(0,2000), xlab=\"Speed over Ground\", main=\"Speed over Ground, Between Consecutive Points\\nFiltered to HPE<1\")\n abline(v=quantile(red2$spd_mps, .995, na.rm=T), col=\"red\", lty=2)\n```\n\nTo Do next:\nwork through following code to identify and remove points with speed in previous and subsequent steps >10.6mps\n        \n    # create new columns in dataframe\n     red2$prevspd = NA\n     red2$badpos = NA\n    \n    # put the previous speed on the same line as the current speed\n     red2$prevspd <- c(NA,red2$spd_mps[1:(nrow(red2)-1)])\n      \n    # if there one speed less than the cuttoff, consider the detection okay (in reality may not be, but it's gonna be more complicated)\n    # if two subsequent speeds are greater than the cuttoff, we have a bad detection\n    #    - the bad point should have high speeds in the line before it (step leading to it) and in its line (step leading from it)\n    #    - so it is the second high value in a pair that is in the same line as the bad position\n     red.gp = red2 %>%\n       group_by(id) %>%\n       mutate(badpos=(spd_mps>5 & prevspd>5) )  ###### is 5 mps a reasonable cutoff? What should we use? ######\n     rednew = as.data.frame(red.gp)\n    \n    # remove 'bad' positions --> as of June 3, 2015 this removed 322 positions (0.444%) with cutoff of 5mps; removes 414 with cutoff of 4mps\n     badpos = rednew[rednew$badpos==TRUE,]  # included 117 fish\n       badpos.fish = summarize(group_by(badpos, id), nremoved=n())\n    \n     red2new = rednew[rednew$badpos==FALSE,]\n\n\n     \nrun through ltraj again to recalculate speeds     \n    \n    # reduce to basic data, make the coords spatial, and convert to ltraj\n     red2base = red2new[c(\"x\",\"y\",\"date\",\"id\",\"run\",\"HPE\")]\n      red2base = red2base[!is.na(red2base$x),]  # somehow the previous processs adds and NA into the dataframe\n      red2base$date = as.POSIXct(red2base$date)\n      ixy = data.frame(red2base[,c(\"id\",\"x\",\"y\")])\n        coordinates(ixy) = c(\"x\",\"y\")\n        proj4string(ixy) = CRS(\"+proj=utm +zone=10 +ellps=WGS84 +datum=WGS84 +units=m +no_defs\")\n      \n     red3 = as.ltraj(xy=red2base[,c(\"x\",\"y\")], date=red2base$date, id=red2base$id, infolocs = red2base[,c(\"id\",\"run\",\"HPE\")])\n    \n    # convert back to dataframe \n     red3.df = ld(red3)\n       red3.df$spd_mps = red3.df$dist/red3.df$dt\n    \n    \n    \ncheck for improved speeds\n\n     range(red3.df$spd_mps, na.rm=T)  # STILL has a speed of 73.1 mps. =/\n    \n     trash = red3.df[red3.df$spd_mps>5,]\n       trash = trash[!is.na(trash$id),]\n       dim(trash)  # still 368 lines with high speeds. better, but not done yet. =/\n       ht(trash)\n\n\nMaybe run process again? Think through this final step once more\n\nThen write out new dataframe; not sure if I can make this concise enough to integrate into \"Final_Filtering.Rmd\"",
    "created" : 1471043557391.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2241521974",
    "id" : "163260F3",
    "lastKnownWriteTime" : 1471049796,
    "path" : "~/GitHub/Fremont16/Exploration_DataFilteringSpeed.Rmd",
    "project_path" : "Exploration_DataFilteringSpeed.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_markdown"
}