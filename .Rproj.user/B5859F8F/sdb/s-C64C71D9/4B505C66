{
    "contents" : "---\ntitle: \"Exploration for Data Filtering HPE\"\nauthor: \"Anna Steel\"\ndate: \"August 10, 2016\"\noutput: html_document\n---\n\n```{r, include=FALSE} \n# required packages\nlibrary(dplyr)\nlibrary(sp)\nlibrary(rgdal)\nlibrary(rgeos)\nlibrary(ggplot2)\nlibrary(grid) \nlibrary(cowplot)\nlibrary(viridis)\n```\n\n### Read in Data \n- Open script from Fremont16.Rproj in GitHub to ensure directories are correct\n``` {r, echo=FALSE}\n load(\"Maestros/alldf.RData\")\n options(\"digits.secs\"=6)\n alldf$Time <- as.POSIXct(as.character(alldf$Time), format=\"%Y-%m-%d %H:%M:%OS\", tz = \"GMT\")\n\n # N fish & positions beginning in dataframe\n print(paste0(\"Prior to filtering, \",nrow(alldf),\" total posotions in dataset\"))\n print(paste0(\"Prior to filtering, \",length(unique(alldf$Id)),\" inidividual fish positioned\"))\n```\n\n### Initial Data Cleaning\n- remove exessively high HPEs (<1000) for ease later\n- reduce dataset to only postions recorded after full VPS array was in place (don't yet have removal dates, so not incorporated here)\n- Create points in a spatial dataframe as well (both lat-long WGS84 & UTM)\n- other steps to include here?\n\n``` {r, echo=FALSE}\n # excessive HPEs (>1000)\n alldf <- alldf[alldf$Hpes<1000,]  # removes 5 detections\n  print(paste0(\"Removing \",nrow(alldf[alldf$Hpes>=1000,]),\" positions with HPEs > 1000\"))\n \n # incomplete array\n alldfg <- alldf[alldf$Time > as.POSIXct(\"2016-02-109 14:00:00\", tz=\"GMT\"),]\n  print(paste0(nrow(alldf) - nrow(alldfg),\" positions removed due to incomplete VPS array\"))\n  \n # sp dataframes\nalldfg.sp <- SpatialPointsDataFrame(coords = alldfg[,c(\"Longitude\",\"Latitude\")], \n              data = alldf, proj4string=CRS(\"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\"))\n        # confirmed string with VEMCO; the XY coords in azimuthal equal area\nalldfg.utm <- spTransform(alldfg.sp, CRS(\"+proj=utm +zone=10 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0\"))\n\n```\n\n***\n\n### Explore HPEs relationship with measured error for sync and reference tags \n- Only positions with Hpes<1000\n- Uses XY coordinates from VEMCO (Azimuthal Equal Area Projection)\n\n``` {r, echo=FALSE, warning=FALSE}\n   allsync <- read.csv(\"C:/Users/Anna/Documents/03_SacBankUSACE/FremontWeir2016/DATA/Positions/AllSyncRef.csv\")\n\n   options(\"digits\"=15)\n   calibsync <- read.csv(\"C:/Users/Anna/Documents/03_SacBankUSACE/FremontWeir2016/DATA/AnalysisPack1/CalibratedStationPositions.csv\")\n   calib.nameindex = read.csv(\"C:/Users/Anna/Documents/03_SacBankUSACE/FremontWeir2016/DATA/AnalysisPack1/CalibratedStationPositionsIndex.csv\")\n   calibsync <- merge(calib.nameindex, calibsync, by=\"Name\", all.x=T)\n    names(calibsync) <- c(\"Name\",\"Id\",\"LongId\",\"TrueLat\",\"TrueLon\",\"TrueX\",\"TrueY\")\n  \n   allsync.calib <- merge(allsync, calibsync[,c(\"Id\",\"TrueLat\",\"TrueLon\", \"TrueX\",\"TrueY\")], by=\"Id\", all.x=T) \n    allsync.calib <- allsync.calib[allsync.calib$Hpes<1000,]\n\n  # Calculate distance btwn lat-long coords\n   allsync.calib$error_m =  sqrt((allsync.calib$TrueX - allsync.calib$X)^2 + (allsync.calib$TrueY - allsync.calib$Y)^2)\n  \n  # point data for measured error vs HPEs   \n   plot(allsync.calib$error_m ~ allsync.calib$Hpes, xlim=c(0,1000), ylab=\"measured error\", xlab=\"HPEs\")\n    \n  # calculate average errors for binned data\n    hpetable = dplyr::select(allsync.calib, error_m, Hpes)\n    hpetable = hpetable[hpetable$Hpes<=50,]     # subset b/c 99.9% of all positions have HPEs<43\n\n   binsize=0.25\n    breaks = binsize*(c(0:(50/binsize)))[1:200]\n    hpetable$group = findInterval(hpetable$Hpes,breaks)\n\n   binstats = hpetable %>%\n     group_by(group) %>%\n     summarize( meanHPEm=mean(error_m), \n                medianHPEm=median(error_m),\n                quant90HPEm=quantile(error_m, 0.9),\n                quant95HPEm=quantile(error_m, 0.95))%>%\n     mutate(bincent = (binsize*group)-(binsize/2)) %>%\n     data.frame()\n\n  # plot bin moments\n   viridiscol = viridis(4)\n    hpestats = ggplot(binstats, aes(x=bincent, y=quant95HPEm)) + #95%\n         geom_point(aes(x=bincent, y=meanHPEm), colour=viridiscol[1]) + \n         geom_point(aes(x=bincent, y=medianHPEm), colour=viridiscol[2]) + \n         geom_point(aes(x=bincent, y=quant90HPEm), colour=viridiscol[3]) + \n         #geom_point(aes(x=bincent, y=quant95HPEm), colour=viridiscol[4]) + \n         geom_smooth(aes(x=bincent, y=meanHPEm), colour=viridiscol[1], se=FALSE) + \n         geom_smooth(aes(x=bincent, y=medianHPEm), colour=viridiscol[2], se=FALSE) + \n         geom_smooth(aes(x=bincent, y=quant90HPEm), colour=viridiscol[3], se=FALSE) + \n         #geom_smooth(aes(x=bincent, y=quant95HPEm), colour=viridiscol[4], se=FALSE) + \n         geom_hline(yintercept = 5, lty=2) + geom_hline(yintercept = 10, lty=3) +\n         annotate(\"text\",x=0, y=90, label=\"Sync and Reference\\nTag Positions\", size=5,adj=0) + \n         annotate(\"text\",x=-0.25, y=7.5, label=\"Error = 5m\", colour=\"gray70\", size=3,adj=0) + \n         annotate(\"text\",x=-0.25, y=12, label=\"Error = 10m\", colour=\"grey70\", size=3, adj=0) + \n         annotate(\"text\",x=1, y=0, label=\"mean\", colour=viridiscol[1]) + \n         annotate(\"text\",x=3, y=0, label=\"median\", colour=viridiscol[2]) + \n         annotate(\"text\",x=5, y=0, label=\"90%ile\", colour=viridiscol[3]) + \n         #annotate(\"text\", x=7, y=0, label=\"95%ile\",colour=viridiscol[4]) +\n        theme_bw() + ylab(\"Measured Error\") + xlab(\"Calculated HPEs\") + xlim(-0.5,8) + ylim(0,100)\n    \n    # create a table to plot the % of data at each threshold of HPEs  (time consuming step)\n    cumperc = data.frame(HPEs = seq(0,50, by=.25), CumPos = NA, PercPos=NA)\n    for(i in 1:nrow(cumperc)) {cumperc[i,2] <- nrow(allsync[allsync$Hpes<cumperc[i,1],])}\n    cumperc$PercPos = cumperc$CumPos / nrow(allsync)\n    \n    hpeperc = ggplot(cumperc, aes(x=HPEs-.25/2, y=PercPos, width = .225)) + geom_bar(stat=\"identity\", fill=\"grey80\") + theme_bw() + xlim(-0.5, 8) + xlab(\"Calculated HPEs\") + ylab(\"% of Positions Retained\")\n    \n    png(\"Graphics/HPE_MeasVsCalib.png\", width=5, height=6, units=\"in\", res=600)\n    ggdraw() + draw_plot(hpestats, 0.05,.3,0.95,.7) + draw_plot(hpeperc, 0.05, 0, 0.95, .275) +\n      draw_plot_label(c(\"A\",\"B\"),c(0,0), c(.95,.20), size=12)\n    dev.off()\n    \n    print(paste0(\"At threshold of HPEs<1, mean measured error (m) of sync/ref positions = \",round(mean(allsync.calib$error_m[allsync.calib$Hpes<1]),2)))\n    print(paste0(\"At threshold of HPEs<1, median measured error (m) of sync/ref positions = \",round(median(allsync.calib$error_m[allsync.calib$Hpes<1]),2)))\n    print(paste0(\"At threshold of HPEs<1, 90%ile of measured error (m) of sync/ref positions = \",round(quantile(allsync.calib$error_m[allsync.calib$Hpes<1],0.9),2)))\n    print(paste0(\"At threshold of HPEs<1, \", round(nrow(allsync.calib[allsync.calib$Hpes<1,])/nrow(allsync.calib)*100,2), \"% of sync/ref positions retained\"))     \n```    \nBased on these graphics I will use a HPE filtering threshold of HPE=1; this seems to be a nice tradeoff between precision (mean ~ 5m in HPE bin 0.75-1) and quantity of data (~80% of data retained). \n\n***\n\n### Spatial distribution of HPEs in fish positions (Similiar to Fig 9 in 2015 report)\n- Eventually will add river line to these plots but needs more research to do in ggplot\n``` {r, echo=FALSE, warnings=FALSE, fig.height=9}\n  # Fig 9, similar  \n  nHighHpe <- nrow(alldfg[alldfg$Hpes>=5,])\n  nLowHpe <- nrow(alldfg[alldfg$Hpes<5 & alldfg$Hpes>=1,])\n  nKeepHpe <- nrow(alldfg[alldfg$Hpes<1,])\n  \n  percHigh <-(nHighHpe/(nLowHpe+nHighHpe+nKeepHpe))*100\n  percLow <-(nLowHpe/(nLowHpe+nHighHpe+nKeepHpe))*100\n  percKeep <- (nKeepHpe/(nLowHpe+nHighHpe+nKeepHpe))*100\n    \n  # read in the river channel and project properly\n  riverbank = readOGR(dsn=\"GIS/2004_channel\", layer=\"2004_channel_freTightclipWGS84\")\n     # convert to be useful in ggplot; still not sure what this actually does       \n      ggriverbank <- fortify(riverbank, region=\"BYDEL\")\n      \n    highhpe=ggplot(data=alldfg[alldfg$Hpes>=5 & alldfg$Hpes<50,], aes(y=Latitude, x=Longitude, colour=Hpes)) + \n      geom_point(size=1.5) + \n      scale_colour_gradient2(name=\"HPEs\", low = \"green3\", mid=\"yellow\", high = \"red\", midpoint=15, space = \"rgb\", na.value = \"grey50\", guide = \"colourbar\") +\n      ggtitle(paste0(\"Positional HPEs > 5: \",round(percHigh,1),\"% of all positions\")) +\n      scale_y_continuous(breaks=seq(38.758,38.764,0.001)) + \n      scale_x_continuous(breaks=seq(-121.672, -121.664, 0.001)) +\n      coord_fixed() + \n      theme_bw() + theme(title=element_text(vjust=2), axis.title.x=element_text(vjust=-.5),axis.title.y=element_text(vjust=1))\n\n# other code that sucessfully adds river line; unsure why I can't integrate it easily into the above\n#     ptdens.keep =  ggplot(data=alldfg[alldfg$Hpes>=5 & alldfg$Hpes<50,],aes(Longitude,Latitude)) + \n#             geom_point(alpha=.1, color=\"grey80\") + \n#             scale_fill_continuous(low=\"white\",high=\"blue\") +\n#             guides(alpha=\"none\") + coord_fixed(ratio=1) + \n#             geom_path(data = ggriverbank, aes(long, lat, group=group)) +\n#             scale_y_continuous(label=roundfunc) +  scale_x_continuous(label=roundfunc) + \n#             commonTheme\n\n    \n    \n    lowhpe=ggplot(alldfg[alldfg$Hpes<5 & alldfg$Hpes>=1,], aes(y=Latitude, x=Longitude, colour=Hpes)) + geom_point(size=1.5) + \n      scale_colour_gradient2(name=\"HPEs\", low = \"green3\", mid=\"yellow\", high = \"red\", midpoint=3, space = \"rgb\", na.value = \"grey50\", guide = \"colourbar\") +\n      ggtitle(paste0(\"Positional HPEs from 1 to 5: \",round(percLow,1),\"% of all positions\")) +\n      scale_y_continuous(breaks=seq(38.758,38.764,0.001)) + \n      scale_x_continuous(breaks=seq(-121.672, -121.664, 0.001)) +\n      coord_fixed() + \n      theme_bw() + theme(title=element_text(vjust=2), axis.title.x=element_text(vjust=-.5),axis.title.y=element_text(vjust=1))\n    \n    keephpe=ggplot(alldfg[alldfg$Hpes<1,], aes(y=Latitude, x=Longitude, colour=Hpes)) + geom_point(size=1.5) + \n      scale_colour_gradient2(name=\"HPEs\", low = \"green3\", mid=\"yellow\", high = \"red\", midpoint=.8, space = \"rgb\", na.value = \"grey50\", guide = \"colourbar\") +\n      ggtitle(paste0(\"Positional HPEs < 1: \",round(percKeep,1),\"% of all positions\")) +\n      scale_y_continuous(breaks=seq(38.758,38.764,0.001)) + \n      scale_x_continuous(breaks=seq(-121.672, -121.664, 0.001)) +\n      coord_fixed() + \n      theme_bw() + theme(title=element_text(vjust=2), axis.title.x=element_text(vjust=-.5),axis.title.y=element_text(vjust=1))\n    \n    png(\"Graphics/Figure9_HPE_Spatial_Distn.png\", width=6, height=9, units=\"in\", res=600)\n     plot_grid(highhpe, lowhpe, keephpe, nrow=3, ncol=1)\n    dev.off()\n```\n\n###  Implement HPEs threshold in filtering\n- This DOES NOT match the report from VEMCO (they report 106,529 or 87% after filtering to HPE<1)\n- I need to get the tagID metadata from someone; suspect there are tags here that aren't fish tags\n```{r, echo=FALSE, warnings=FALSE}  \n  reddf = alldfg[alldfg$Hpes < 1,]\n   print(\"After filtering @ HPEs<1, dataset retained:\")\n   print(paste0(\"  \",nrow(reddf),\" positions,\")) # 110,211  \n   print(paste0(\"  \",round(nrow(reddf)/nrow(alldfg)*100,2), \"% of fish tag positions\"))  # 84.35%\n   print(paste0(\"  \",length(unique(reddf$Id)),\" individual fish\"))  # 438\n   \n  reddf.sp <- SpatialPointsDataFrame(coords = reddf[,c(\"Longitude\",\"Latitude\")], data = reddf, proj4string=CRS(\"+proj=aeqd +lat_0=38.759985 +lon_0=-121.666908 +x_0=1000 +y_0=1000 +datum=WGS84\"))\n   # proj4string directly from VEMCO documentation\n  \n  dropdf = alldfg[alldfg$Hpes >=1,]\n  dropdf.sp <- SpatialPointsDataFrame(coords = dropdf[,c(\"Longitude\",\"Latitude\")], data = dropdf, proj4string=CRS(\"+proj=aeqd +lat_0=38.759985 +lon_0=-121.666908 +x_0=1000 +y_0=1000 +datum=WGS84\"))\n   # proj4string directly from VEMCO documentation\n \n```\n\nHere is an excerpt from VEMCO's results document that is returned with the post-processed VPS dataset, regarding thier estimate of the precision of the fish positions:\n\n> Fish tag precision is estimated here using a simple method of comparing pairs of calculated positions\n> that are very close in time, based on the knowledge that over a short period of time a fish will travel a\n> relatively short distance. The time durations between successive transmissions of a fish tag in this study\n> follow a pseudorandom sequence, with a minimum of 1.0 seconds, a maximum of 2.0 seconds, and an\n> average of 1.5 seconds.\n> For each of the HPEs filters, the retained positions are analyzed as follows:\n> • Pairs of positions from the same transmitter that are within 2.0 seconds of each other are\n> identified, and the horizontal distances between these pairs of positions are calculated\n> • Selected percentiles of these horizontal distances are calculated\n> The following is a summary of these analyses:\n> HPEs  # Pos  % pos  50%ile 80%ile 90%ile 95%ile\n> 0.2   25792   21%   1.34    2.04    2.56   3.16\n> 0.5   83658   68%   1.57    2.54    3.45   4.62\n> 1.0  106529   87%   1.68    2.93    4.21   5.86\n> For example, using an HPEs filter of 1.0, half of the pairs of calculated positions that are within 2.0\n> seconds of each other are less than 1.68 metres apart, and 80% are within 2.93m.\n> Note that these statistics cannot be compared directly with the corresponding statistics for sync and\n> reference tags because they include a component based on an average of 1.5 seconds of fish motion.\n\n***\n\n### Histograms of individual detections/GoodBasic positions for each calculated fish location:\n- not of much interest but code was already written\n``` {r, echo=FALSE} \n  ### not in report ###\n par(mfrow=c(2,2))\n  hist(alldfg$GoodBasicCount, breaks=25, main=\"All Positions:\\nNumber of Good Basic positions \\nper estimated position\", xlab=\"N Good Basic Positions\", xlim=c(0,25))\n  hist(reddf$GoodBasicCount, breaks=25, main=\"Positions HPEs<1:\\nNumber of Good Basic positions \\nper estimated position\", xlab=\"N Good Basic Positions\", xlim=c(0,25))\n\n  hist(alldfg$DetectionsCount, breaks=25, main=\"All Positions:\\nNumber of Detections \\nper estimated position\", xlab=\"N Detections\", xlim=c(0,25))\n  hist(reddf$DetectionsCount, breaks=25, main=\"Positions HPEs<1:\\nNumber of Detections \\nper estimated position\", xlab=\"N Detections\", xlim=c(0,25))\n```\n\n### Positions remaining per fish (Figs 8 and 10 in 2015 report)\n- considered positions per fish before filtering by HPE and after\n+ plots tracks of outliers to examine for predator-like behavior patters\n+ 'outliers' defined according to standard boxplot metrics: all those points greater than 1.5*IQR + 75%ile of the data.\n- plots percent of positions remaining for individual fish after filtering at HPE<1 (Fig 8)\n```{r, echo=FALSE, fig.height=8, fig.width=7}\n # prior to HPE filtering\n all.npf = alldfg %>%\n   group_by(Id) %>%\n   summarize(npos.all=n())%>%\n   data.frame()\n\n  summary(all.npf$npos.all)\n  \n  png(\"Graphics/Figure8a_HPE_PosPerFish.png\", width=6, height=5, units=\"in\", res=600)\n   hist(all.npf$npos.all, xlim=c(0,1000), breaks=250, ylim=c(0,110),\n        xlab=c(\"Number of Positions\"), main=\"Positions recorded per fish\\nprior to HPE filtering\")  \n    text(x=800, y=40, \"Removed two individual tags\\nw/ > 5000 detections\", font=3)\n  dev.off()\n\n  outliers.pre = all.npf[all.npf$npos.all %in% sort(boxplot.stats(all.npf$npos.all)$out),]\n      \n  ggplot(data=alldfg[alldfg$Id %in% outliers.pre$Id,], aes(x=Longitude, y=Latitude)) + geom_point() +\n    facet_wrap(~Id, ncol=4) + ggtitle(\"Tracks of outliers, positions not filtered\")\n\n # after HPE filtering\n red.npf = reddf %>%\n   group_by(Id) %>%\n   summarize(npos.red= n()) %>%\n   data.frame()\n     \n  summary(red.npf$npos.red)   \n  \n  png(\"Graphics/Figure8b_HPE_PosPerFish.png\", width=6, height=5, units=\"in\", res=600)\n    hist(red.npf$npos.red, xlim=c(0,1000), breaks=100, ylim=c(0,110), \n         xlab=c(\"Number of Positions\"), main=\"Positions recorded per fish\\nafter HPE filtering\")  \n     text(x=800, y=40, \"Removed two individual tags\\nw/ > 2000 detections\", font=3)\n  dev.off()\n  \n  outliers.post = red.npf[red.npf$npos.red %in% sort(boxplot.stats(red.npf$npos.red)$out),]\n        \n  ggplot(data=reddf[reddf$Id %in% outliers.post$Id,], aes(x=Longitude, y=Latitude)) + geom_point() +\n              facet_wrap(~Id, ncol=4) + ggtitle(\"Tracks for outliers, positions filtered HPEs<1\")\n```\n```{r, echo=FALSE, warnings=FALSE}\n  # percent of positions remaining per individual fish (Fig 10)\n  \n comp.npf = merge(all.npf, red.npf, by=\"Id\")\n comp.npf$perc.remain = comp.npf$npos.red / comp.npf$npos.all\n \n filtlevel = ggplot(data = alldfg, aes(Hpes)) + \n    geom_histogram(binwidth=.2, col=I(\"black\"), fill=\"grey95\") + \n    ggtitle(\"Calculated HPEs, all positions\") + \n    scale_x_continuous(breaks=seq(0,10,2), limits=c(0,10)) + \n    xlab(\"HPEs\") + ylab(\"Frequency\") + \n    theme_bw() + \n    theme(title=element_text(vjust=2), \n          axis.title.x=element_text(vjust=-.5),\n          axis.title.y=element_text(vjust=1.2),\n          plot.margin=unit(c(1,1,1.25,1), \"cm\")) +\n    geom_vline(xintercept = 1, col=\"red\", lty=2) + \n    annotate(\"text\",x=1.1, y=50100, label=\"HPEs = 1\", col=\"red\", adj=0, size=4)\n\n filt.ppf = ggplot(data = comp.npf, aes(npos.red)) + \n    geom_histogram(binwidth=25, col=I(\"black\"), fill=\"grey95\") + \n    ggtitle(\"Filtered at HPEs<1:\n            \nPositions per Fish\") +  \n    scale_x_continuous(breaks=seq(0,500,100), limits=c(0,500)) + \n    scale_y_continuous(breaks=seq(0,70,20), limits=c(0,70)) + \n    xlab(\"N Positions\") + ylab(\"Frequency\") + \n    theme_bw() + \n    theme(title=element_text(vjust=2), \n          axis.title.x=element_text(vjust=-.5),\n          axis.title.y=element_text(vjust=1.2),\n          plot.margin=unit(c(.1,1,.75,.5), \"cm\"))\n\n filt.proprem = ggplot(data = comp.npf, aes(perc.remain)) + \n    geom_histogram(binwidth=.025, col=I(\"black\"), fill=\"grey95\") + \n    ggtitle(\"Proportion Positions\\nRemaining per Fish\") + \n    scale_x_continuous(breaks=seq(0,1,.2), limits=c(0,1)) + \n    scale_y_continuous(breaks=seq(0,85,20), limits=c(0,85)) + \n    xlab(\"Proportion\") + ylab(\"Frequency\") + \n    theme_bw() + \n    theme(title=element_text(vjust=2), \n          axis.title.x=element_text(vjust=-.5),\n          axis.title.y=element_text(vjust=1.2),\n          plot.margin=unit(c(.1,1,.75,.5), \"cm\"))\n\n        \n       png(\"Graphics/Figure10_Filtered_ComboFigure.png\", width=8, height=4.75, units=\"in\", res=300)\n        ggdraw() + \n          draw_plot(filtlevel, x=0,y=0,width=.6, height=1) + \n          draw_plot(filt.ppf, x=.6,y=.475,width=.4, height=0.45) + \n          draw_plot(filt.proprem, x=.6,y=0.025,width=.4, height=0.45) +  \n          draw_plot_label(label=c(\"A\",\"B\",\"C\"), x=c(0.05,0.62,0.62), y=c(.975,.88,.45), size=16)\n        dev.off()\n```\n \n### Look at fish which >40% positions removed\n- how many are there?\n- are the tracks indicative of predator behavior?\n- where are the errors?\n```{r, echo=FALSE, warnings=FALSE}\n  # how many?      \n   poorHpes = comp.npf[comp.npf$perc.remain<=.6,]  # 2 fish\n      print(paste0(\"Only \",nrow(poorHpes),\" fish with >40% of positions removed\"))\n   poor.dfg = alldfg[alldfg$Id %in% poorHpes$Id,]\n\n  # where are the errors in the 'bad' tracks?\n  ggplot(data=poor.dfg[order(poor.dfg$Hpes),], aes(x=Longitude, y=Latitude, color=(Hpes))) + \n    geom_point() + coord_fixed() + \n    facet_wrap(~Id, ncol=4) + \n    scale_colour_gradientn(colours=rev(viridis(5)))\n  \n  # does the track change significantly when the poor Hpes points are removed? No\n  poor.pre = ggplot(data=alldfg[alldfg$Id %in% poorHpes$Id,], aes(x=Longitude, y=Latitude)) + geom_point() + \n    facet_wrap(~Id, ncol=4) + ggtitle(\"'Poor' tracks with no filtering\")\n  poor.post = ggplot(data=alldfg[alldfg$Id %in% poorHpes$Id & alldfg$Hpes<1,], aes(x=Longitude, y=Latitude)) + geom_point() + facet_wrap(~Id, ncol=4) + ggtitle(\"'Poor' tracks filtered at HPEs < 1\")\n\n  plot_grid(  poor.pre, poor.post, ncol=1, nrow=2)\n```  \n\n# move code below here to new file for filtering based on predators\n\n### Look at fish tracks for potential predators\n- high number of detections\n+ 1st plot shows tracks for fish with the top 5% of recorded positions \n- long passage time\n- movement upstream \n```{r, echo=FALSE, warnings=FALSE}\n   # track of top 5% N positions, color coded by hour of day\n   highN.red = red.npf[red.npf$npos.red >= quantile(red.npf$npos.red, .95),]\n   ggplot(data=reddf[reddf$Id %in% highN.red$Id,], aes(x=Longitude, y=Latitude)) +\n     geom_path(aes(colour=as.POSIXlt(Time)$hour)) + \n     facet_wrap(~Id, ncol=5) + scale_colour_gradientn(colours=rainbow(6), name=\"Hour of Day\") + \n     ggtitle(\"Highest 5% N positions, positions filtered HPEs<1\") + \n     theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\n  # Pull arrival and departure times and locations\n   fl.df = reddf %>%\n      group_by(Id) %>%\n      slice(c(1,n()))\n   fl.df = as.data.frame(fl.df)\n   fl.df$fl = rep(c(\"F\",\"L\"),nrow(fl.df)/2)  \n  \n    ff = fl.df[fl.df$fl==\"F\",c(\"Id\",\"Time\",\"Latitude\",\"Longitude\")] \n     names(ff) = c(\"Id\",\"F.time\",\"F.lat\",\"F.long\")\n    ll = fl.df[fl.df$fl==\"L\",c(\"Id\",\"Time\",\"Latitude\",\"Longitude\")]\n     names(ll) = c(\"Id\",\"L.time\",\"L.lat\",\"L.long\")\n  \n   fl.df2 = merge(ff,ll)\n  \n   # calculate passage time through array, and look at long pass times\n   fl.df2$arraytime_min = as.numeric(difftime(fl.df2$L.time, fl.df2$F.time))\n   \n   hist(fl.df2$arraytime_min, breaks=5000, xlim=c(0,300), \n        main=\"Passage time for all fish, filtered at HPEs<1\", xlab=\"Passage Time (min)\")\n    long.fish = fl.df2[fl.df2$arraytime_min > 150,]$Id\n      # 36379 36398 36472 36483 36612 36675 65068 65069 65070 65073 65124\n   print(paste0(length(long.fish),\" individual tags with >150 min passage time\"))\n   print(paste0(\"TagIDs \", long.fish))\n\n    \n   # calculate location of final detection; upstream?  \n   hist(fl.df2$L.long, xlab=\"Longitude (upstream to downstream)\", \n      main=\"Histogram of final detection location\")\n   abline(v=-121.6679,col=\"red\", lty=2)\n    upfish = fl.df2[fl.df2$L.long < -121.6679,]$Id\n      # 36472 65124\n    print(paste0(length(upfish),\" fish exited at upstream end of array\"))\n    print(paste0(\"TagIDs \", upfish))\n    \n    # plot upfish and longfish\n    ggplot(data=reddf[reddf$Id %in% unique(c(upfish, long.fish)),], aes(x=Longitude, y=Latitude)) +\n     geom_path(aes(colour=as.POSIXlt(Time)$hour)) + \n     facet_wrap(~Id, ncol=4) + scale_colour_gradientn(colours=rainbow(6), name=\"Hour of Day\") + \n     ggtitle(\"Questionable Smolts:\\nUpstream Movement and Long-Passage, positions filtered HPEs<1\") + \n     theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\n```\n\n### Last to-do: Use these graphics to decide which tags to evaluate further for evidence of predation\n- perhaps best to re-address this after the filtering for speed? Four of these strange tracks might be due to errors which would be captured in a speed-filter",
    "created" : 1470950911898.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "56|78|135|3|\n237|94|247|3|\n",
    "hash" : "2335966139",
    "id" : "4B505C66",
    "lastKnownWriteTime" : 1471043597,
    "path" : "~/GitHub/Fremont16/Exploration_DataFiltering.Rmd",
    "project_path" : "Exploration_DataFiltering.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}